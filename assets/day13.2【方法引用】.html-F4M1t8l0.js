const e=JSON.parse('{"key":"v-260d697b","path":"/back-base/2.Java%E6%A0%B8%E5%BF%83/day13.2%E3%80%90%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%91.html","title":"第二章 方法引用","lang":"zh-CN","frontmatter":{"description":"第二章 方法引用 在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ 2.1 冗余的Lambda场景 来看一个简单的函数式接口以应用Lambda表达式： @FunctionalInterface public interface Printable { void print(String str); }","head":[["meta",{"property":"og:url","content":"https://apzs.github.io/back-base/2.Java%E6%A0%B8%E5%BF%83/day13.2%E3%80%90%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%91.html"}],["meta",{"property":"og:site_name","content":"apzs"}],["meta",{"property":"og:title","content":"第二章 方法引用"}],["meta",{"property":"og:description","content":"第二章 方法引用 在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？ 2.1 冗余的Lambda场景 来看一个简单的函数式接口以应用Lambda表达式： @FunctionalInterface public interface Printable { void print(String str); }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-05T06:05:15.000Z"}],["meta",{"property":"article:author","content":"apzs"}],["meta",{"property":"article:modified_time","content":"2024-03-05T06:05:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第二章 方法引用\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-05T06:05:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"apzs\\",\\"url\\":\\"https://apzs.eu.org\\"}]}"]]},"headers":[{"level":2,"title":"2.1 冗余的Lambda场景","slug":"_2-1-冗余的lambda场景","link":"#_2-1-冗余的lambda场景","children":[]},{"level":2,"title":"2.2 问题分析","slug":"_2-2-问题分析","link":"#_2-2-问题分析","children":[]},{"level":2,"title":"2.3 用方法引用改进代码","slug":"_2-3-用方法引用改进代码","link":"#_2-3-用方法引用改进代码","children":[]},{"level":2,"title":"2.4 方法引用符","slug":"_2-4-方法引用符","link":"#_2-4-方法引用符","children":[{"level":3,"title":"语义分析","slug":"语义分析","link":"#语义分析","children":[]},{"level":3,"title":"推导与省略","slug":"推导与省略","link":"#推导与省略","children":[]}]},{"level":2,"title":"2.5 通过对象名引用成员方法","slug":"_2-5-通过对象名引用成员方法","link":"#_2-5-通过对象名引用成员方法","children":[]},{"level":2,"title":"2.6 通过类名称引用静态方法","slug":"_2-6-通过类名称引用静态方法","link":"#_2-6-通过类名称引用静态方法","children":[]},{"level":2,"title":"2.7 通过super引用成员方法","slug":"_2-7-通过super引用成员方法","link":"#_2-7-通过super引用成员方法","children":[]},{"level":2,"title":"2.8 通过this引用成员方法","slug":"_2-8-通过this引用成员方法","link":"#_2-8-通过this引用成员方法","children":[]},{"level":2,"title":"2.9 类的构造器引用","slug":"_2-9-类的构造器引用","link":"#_2-9-类的构造器引用","children":[]},{"level":2,"title":"2.10 数组的构造器引用","slug":"_2-10-数组的构造器引用","link":"#_2-10-数组的构造器引用","children":[]}],"git":{"createdTime":1709618715000,"updatedTime":1709618715000,"contributors":[{"name":"zhaoshuo","email":"apzs@foxmaill.com","commits":1}]},"readingTime":{"minutes":7.37,"words":2212},"filePathRelative":"back-base/2.Java核心/day13.2【方法引用】.md","localizedDate":"2024年3月5日","excerpt":"<h1> 第二章 方法引用</h1>\\n<p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？</p>\\n<h2> 2.1 冗余的Lambda场景</h2>\\n<h5> 来看一个简单的函数式接口以应用Lambda表达式：</h5>\\n<div class=\\"language-java line-numbers-mode\\" data-ext=\\"java\\"><pre class=\\"language-java\\"><code><span class=\\"token annotation punctuation\\">@FunctionalInterface</span>\\n<span class=\\"token keyword\\">public</span> <span class=\\"token keyword\\">interface</span> <span class=\\"token class-name\\">Printable</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">print</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">String</span> str<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
